<h1 align="center">
    IoC (Inversion of Control)
    <img src="https://cdn-icons-png.flaticon.com/512/9502/9502462.png" alt="image example" align="center" width="100px">
</h1>

IoC (Inversion of Control), ou Invers√£o de Controle, √© a troca da responsabilidade de criar objetos. Em vez de voc√™ ficar usando `new` para instanciar tudo, voc√™ transfere essa tarefa para o Spring.

Esses objetos que s√£o instanciados e gerenciados automaticamente pelo Spring s√£o chamados de **Beans**.

Esses Beans ficam "guardados" e dispon√≠veis dentro do Container IoC do Spring, que √© mais formalmente conhecido como `Application Context`. √â esse "contexto" que o Spring usa para encontrar e injetar os Beans onde e quando voc√™ precisa.

<hr>
<br>

## Beans

Os Beans s√£o criados e disponibilizados pelo Spring de duas formas principais:

- ### Anota√ß√µes (as @Annotations):

    Para suas pr√≥prias classes (como Service, Controller, Repository ou qualquer componente gen√©rico), voc√™ as anota com anota√ß√µes de estere√≥tipo do Spring, como **@Component** (ou **@Service**, **@Controller**, **@Repository**, que s√£o especializa√ß√µes de @Component).

    Ao iniciar sua aplica√ß√£o, o Spring "escanear√°" seu c√≥digo, encontrar√° essas classes anotadas e automaticamente criar√° uma inst√¢ncia (um Bean) delas. Assim, quando outra classe solicita essa depend√™ncia (via @Autowired), o Spring j√° tem o Bean pronto para ser injetado.

    <br>

    ```java
    @Component(value = "bean_insano_1")
    public class Computer {}
    ```

    <br>


    üìñ Quando marcamos uma class com uma annotation: Voc√™ diz: "Spring, por favor, crie e cuide deste objeto para mim."

    üìñ Quando nao definimos o nome do bean, ele vai ter o mesmo nome da Class.

<br>
<br>

- ### @Configuration e M√©todos @Bean:

    Voc√™ cria uma classe anotada com **@Configuration** e, dentro dela, m√©todos que retornam objetos. Esses m√©todos s√£o anotados com **@Bean**.

    Essa forma √© usada quando a cria√ß√£o do objeto √© mais complexa, exige l√≥gica customizada, ou quando voc√™ precisa gerenciar um objeto de uma biblioteca de terceiros (que voc√™ n√£o pode modificar com anota√ß√µes @Component).

    Exemplos: Configurar um cliente para uma API externa (como um RestTemplate), ou definir um Bean complexo para o Swagger/OpenAPI, s√£o exemplos perfeitos.


    <br>

    ```java
    @Configuration
    public class Teste {
        
        @Bean(name = "bean_insano_2")
        public Computer criarBeanComputer(){
            return new Computer();
        }
    }
    ```

    üìñ Quando nao definimos o nome do bean, ele vai ter o mesmo nome do method.

<hr>
<br>

## Localizando nossas Beans

O IoC Container do Spring √©, como vimos, formalmente conhecido como `Application Context`. Ele √© o lugar onde todos os seus Beans gerenciados pelo Spring ficam "guardados".


```java
package com.example.ioc_spring;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class IocSpringApplication {

	public static void main(String[] args) {
		ApplicationContext apcInsano = SpringApplication.run(IocSpringApplication.class, args);

        //pegando apenas 1 bean espec√≠fico
        System.out.println(apcInsano.getBean(Computer.class));

        //pegando todos os beans do container
		for(String i : apcInsano.getBeanDefinitionNames()){
			System.out.println(i);
		}
	}
}
```

<br>
<br>

üìñ Sacou?? O Application Context (o IoC Container do Spring) √© o grande "cofre" onde todos os seus Beans ficam guardados.

Quando voc√™ usa Inje√ß√£o de Depend√™ncia (principalmente via construtor), o Spring vai l√°, pega os Beans que precisa do Application Context e os entrega para sua classe automaticamente.